<!-- training_dashboard.html: Shows live training metrics as a plot -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Training Dashboard</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f7f7f7; }
        .container { max-width: 1400px; margin: 20px auto; background: #fff; padding: 20px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); }
        h1 { text-align: center; margin-bottom: 20px; }
        .charts-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-bottom: 20px; }
        .chart-container { background: #fafafa; padding: 15px; border-radius: 8px; border: 1px solid #e0e0e0; }
        .chart-container h3 { margin: 0 0 10px 0; font-size: 14px; color: #333; }
        .chart-wrapper { position: relative; height: 300px; }
        .error { color: #c00; text-align: center; margin-top: 24px; }
        .refresh-controls { 
            text-align: center; 
            margin: 20px 0; 
            padding: 15px; 
            background: #f8f9fa; 
            border-radius: 8px; 
            border: 1px solid #e9ecef; 
        }
        .refresh-controls label { 
            margin-right: 10px; 
            font-weight: bold; 
            color: #333; 
        }
        .refresh-controls select { 
            padding: 5px 10px; 
            border: 1px solid #ddd; 
            border-radius: 4px; 
            margin-right: 10px; 
        }
        .refresh-controls button { 
            padding: 5px 15px; 
            background: #007bff; 
            color: white; 
            border: none; 
            border-radius: 4px; 
            cursor: pointer; 
        }
        .refresh-controls button:hover { 
            background: #0056b3; 
        }
        .training-info { 
            text-align: center; 
            margin: 15px 0; 
            padding: 15px; 
            background: #e8f4fd; 
            border-radius: 8px; 
            border: 1px solid #bee5eb; 
        }
        .training-time { 
            margin-bottom: 8px; 
            font-size: 14px; 
            color: #0c5460; 
        }
        .training-progress { 
            font-size: 13px; 
            color: #0c5460; 
        }
        .training-estimation { 
            font-size: 13px; 
            color: #0c5460; 
        }
        .config-info { 
            margin: 15px 0; 
            padding: 15px; 
            background: #f8f9fa; 
            border-radius: 8px; 
            border: 1px solid #e9ecef; 
        }
        .config-info h3 { 
            margin: 0 0 12px 0; 
            font-size: 14px; 
            color: #495057; 
            font-weight: 600;
        }
        .config-simple { 
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .config-line { 
            display: flex;
            align-items: center;
            font-size: 13px;
            line-height: 1.4;
        }
        .config-key { 
            color: #6c757d; 
            font-weight: 500;
            min-width: 80px;
            margin-right: 8px;
        }
        .config-val { 
            color: #212529; 
            font-weight: 400;
        }
        .refresh-info { text-align: center; color: #666; font-size: 12px; margin-top: 10px; }
        
        .chart-tooltip {
            position: absolute;
            display: none;
            padding: 8px;
            box-sizing: border-box;
            font-size: 12px;
            text-align: left;
            z-index: 1000;
            pointer-events: none;
            border: 1px solid;
            border-radius: 2px;
            font-family: -apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background: white;
            color: black;
            min-width: 120px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        .chart-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #666;
            font-size: 14px;
        }
        
        .chart-error {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #c00;
            font-size: 12px;
            text-align: center;
            padding: 10px;
        }
        
    </style>
</head>
<body>
    <div class="container">
        <h1>Training Dashboard</h1>
        <div class="training-info">
            <div class="training-time">
                <strong>Training Time:</strong> <span id="training-time">Calculating...</span>
            </div>
            <div class="training-progress">
                <strong>Timesteps:</strong> <span id="total-timesteps">-</span> | 
                <strong>Episodes:</strong> <span id="total-episodes">-</span>
            </div>
            <div class="training-estimation">
                <strong>Progress:</strong> <span id="progress-percentage">-</span> | 
                <strong>Remaining Time:</strong> <span id="remaining-time">Calculating...</span>
            </div>
        </div>
        
        <div class="config-info">
            <h3>Configuration</h3>
            <div class="config-simple">
                <div class="config-line">
                    <span class="config-key">Type:</span>
                    <span class="config-val" id="config-description">Loading...</span>
                </div>
                <div class="config-line">
                    <span class="config-key">Window:</span>
                    <span class="config-val"><span id="config-window-size">-</span> bars (<span id="config-window-duration">-</span>)</span>
                </div>
                <div class="config-line">
                    <span class="config-key">Episode:</span>
                    <span class="config-val"><span id="config-episode-steps">-</span> bars (<span id="config-episode-duration">-</span>)</span>
                </div>
                <div class="config-line">
                    <span class="config-key">Timesteps:</span>
                    <span class="config-val" id="config-total-timesteps">-</span>
                </div>
            </div>
        </div>
        <div class="charts-grid">
            <div class="chart-container">
                <h3>Rewards</h3>
                <div class="chart-wrapper">
                    <div id="rewards-chart"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>Loss</h3>
                <div class="chart-wrapper">
                    <div id="loss-chart"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>Account Overview</h3>
                <div class="chart-wrapper">
                    <div id="account-chart"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>Total Trades</h3>
                <div class="chart-wrapper">
                    <div id="trades-chart"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>Entropy</h3>
                <div class="chart-wrapper">
                    <div id="entropy-chart"></div>
                </div>
            </div>
        </div>
        <div id="error-msg" class="error"></div>
        <div class="refresh-controls">
            <label for="refresh-interval">Refresh Interval:</label>
            <select id="refresh-interval">
                <option value="10">10 seconds</option>
                <option value="30">30 seconds</option>
                <option value="60" selected>60 seconds</option>
                <option value="120">2 minutes</option>
                <option value="300">5 minutes</option>
                <option value="600">10 minutes</option>
                <option value="0">Manual refresh only</option>
            </select>
            <button id="refresh-now">Refresh Now</button>
        </div>
        <div class="refresh-info" id="refresh-info">Auto-refreshing every 60 seconds</div>
    </div>
    
    <!-- Tooltips for each chart -->
    <div id="rewards-tooltip" class="chart-tooltip"></div>
    <div id="loss-tooltip" class="chart-tooltip"></div>
    <div id="account-tooltip" class="chart-tooltip"></div>
    <div id="trades-tooltip" class="chart-tooltip"></div>
    <div id="entropy-tooltip" class="chart-tooltip"></div>
    
    <script>
    // Move tooltips to their respective chart containers
    document.addEventListener('DOMContentLoaded', function() {
        const chartContainers = [
            { chart: 'rewards-chart', tooltip: 'rewards-tooltip' },
            { chart: 'loss-chart', tooltip: 'loss-tooltip' },
            { chart: 'account-chart', tooltip: 'account-tooltip' },
            { chart: 'trades-chart', tooltip: 'trades-tooltip' },
            { chart: 'entropy-chart', tooltip: 'entropy-tooltip' }
        ];
        
        chartContainers.forEach(({ chart, tooltip }) => {
            const chartElement = document.getElementById(chart);
            const tooltipElement = document.getElementById(tooltip);
            if (chartElement && tooltipElement) {
                chartElement.appendChild(tooltipElement);
        }
        });
    });
    </script>
    
    
    
    <script>

    
    async function fetchMetrics() {
        try {
        const resp = await fetch('/api/training_metrics');
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
            }
        return await resp.json();
        } catch (error) {
            console.error('Error fetching metrics:', error);
            return { error: `Failed to fetch metrics: ${error.message}` };
        }
    }
    
    async function fetchTrainingConfig() {
        try {
        const resp = await fetch('/api/training_config');
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
            }
        return await resp.json();
        } catch (error) {
            console.error('Error fetching config:', error);
            return { error: `Failed to fetch config: ${error.message}` };
        }
    }
    
    function safeMap(metrics, key) { 
        return metrics.map(m => m[key] !== undefined && m[key] !== null ? m[key] : null); 
    }
    
    function formatNumber(value, decimals = 2) {
        if (value === null || value === undefined) return 'N/A';
        return typeof value === 'number' ? value.toFixed(decimals) : value.toString();
    }
    
    function formatCurrency(value) {
        if (value === null || value === undefined) return '$N/A';
        return typeof value === 'number' ? `$${value.toFixed(2)}` : `$${value}`;
    }
    
    async function updateTrainingInfo(metrics) {
        if (!metrics || metrics.length === 0) return;
        
        // Get the latest timestep
        const latestTimestep = Math.max(...metrics.map(m => m.timesteps));
        const totalEpisodes = metrics.length;
        
        // Update timesteps and episodes display
        document.getElementById('total-timesteps').textContent = latestTimestep.toLocaleString();
        document.getElementById('total-episodes').textContent = totalEpisodes.toLocaleString();
        
        // Get the latest training time from metrics (real time from training agent)
        const latestMetric = metrics[metrics.length - 1];
        const trainingTimeSeconds = latestMetric.training_time_seconds || 0;
        
        // Convert to human readable format
        const hours = Math.floor(trainingTimeSeconds / 3600);
        const minutes = Math.floor((trainingTimeSeconds % 3600) / 60);
        const seconds = Math.floor(trainingTimeSeconds % 60);
        
        let timeString = '';
        if (hours > 0) {
            timeString = `${hours}h ${minutes}m ${seconds}s`;
        } else if (minutes > 0) {
            timeString = `${minutes}m ${seconds}s`;
        } else {
            timeString = `${seconds}s`;
        }
        
        document.getElementById('training-time').textContent = timeString;
        
        // Calculate remaining time estimation
        try {
            const config = await fetchTrainingConfig();
            if (config.error) {
                document.getElementById('progress-percentage').textContent = 'N/A';
                document.getElementById('remaining-time').textContent = 'Config error';
                return;
            }
            
            const totalTimesteps = config.total_timesteps;
            const progressPercentage = (latestTimestep / totalTimesteps * 100).toFixed(1);
            
            // Update progress percentage
            document.getElementById('progress-percentage').textContent = `${progressPercentage}%`;
            
            // Calculate remaining time
            if (latestTimestep > 0 && trainingTimeSeconds > 0) {
                const timestepsPerSecond = latestTimestep / trainingTimeSeconds;
                const remainingTimesteps = totalTimesteps - latestTimestep;
                const remainingSeconds = remainingTimesteps / timestepsPerSecond;
                
                // Convert remaining time to human readable format
                const remainingHours = Math.floor(remainingSeconds / 3600);
                const remainingMinutes = Math.floor((remainingSeconds % 3600) / 60);
                const remainingSecs = Math.floor(remainingSeconds % 60);
                
                let remainingTimeString = '';
                if (remainingHours > 0) {
                    remainingTimeString = `${remainingHours}h ${remainingMinutes}m ${remainingSecs}s`;
                } else if (remainingMinutes > 0) {
                    remainingTimeString = `${remainingMinutes}m ${remainingSecs}s`;
                } else {
                    remainingTimeString = `${remainingSecs}s`;
                }
                
                document.getElementById('remaining-time').textContent = remainingTimeString;
            } else {
                document.getElementById('remaining-time').textContent = 'Calculating...';
            }
        } catch (error) {
            document.getElementById('progress-percentage').textContent = 'N/A';
            document.getElementById('remaining-time').textContent = 'Error';
        }
    }
    
    async function updateConfigurationInfo() {
        try {
            const config = await fetchTrainingConfig();
            if (config.error) {
                document.getElementById('config-description').textContent = 'Error loading config';
                return;
            }
            
            // Update configuration display
            document.getElementById('config-description').textContent = config.description || 'N/A';
            document.getElementById('config-window-size').textContent = config.window_size?.toLocaleString() || 'N/A';
            document.getElementById('config-episode-steps').textContent = config.max_episode_steps?.toLocaleString() || 'N/A';
            document.getElementById('config-total-timesteps').textContent = config.total_timesteps?.toLocaleString() || 'N/A';
            
            // Calculate human-readable durations (5-minute bars)
            const windowDuration = config.window_size ? Math.round(config.window_size * 5 / 60) : 0; // hours
            const episodeDuration = config.max_episode_steps ? Math.round(config.max_episode_steps * 5 / 60) : 0; // hours
            
            let windowDurationText = '';
            if (windowDuration >= 24) {
                const days = Math.floor(windowDuration / 24);
                const hours = windowDuration % 24;
                windowDurationText = `${days}d ${hours}h`;
            } else {
                windowDurationText = `${windowDuration}h`;
            }
            
            let episodeDurationText = '';
            if (episodeDuration >= 24) {
                const days = Math.floor(episodeDuration / 24);
                const hours = episodeDuration % 24;
                episodeDurationText = `${days}d ${hours}h`;
            } else {
                episodeDurationText = `${episodeDuration}h`;
            }
            
            document.getElementById('config-window-duration').textContent = windowDurationText;
            document.getElementById('config-episode-duration').textContent = episodeDurationText;
            
        } catch (error) {
            document.getElementById('config-description').textContent = 'Error loading config';
        }
    }
    
    function createTradingViewChart(containerId, data, options = {}) {
        const container = document.getElementById(containerId);
        
        if (!container) {
            return null;
        }
        
        // Clear existing chart
        if (window.charts && window.charts[containerId]) {
            window.charts[containerId].remove();
        }
        if (!window.charts) window.charts = {};
        
        const chart = LightweightCharts.createChart(container, {
            width: container.clientWidth || 400,
            height: container.clientHeight || 300,
            layout: {
                background: { color: '#ffffff' },
                textColor: '#333',
            },
            grid: {
                vertLines: { color: '#f0f0f0' },
                horzLines: { color: '#f0f0f0' },
            },
            crosshair: {
                mode: LightweightCharts.CrosshairMode.Normal,
            },
            rightPriceScale: {
                borderColor: '#cccccc',
                scaleMargins: {
                    top: 0.1,
                    bottom: 0.1,
                },
            },
            timeScale: {
                borderColor: '#cccccc',
                timeVisible: true,
                secondsVisible: false,
                rightOffset: 12,
                barSpacing: 3,
                fixLeftEdge: true,
                fixRightEdge: true,
                lockVisibleTimeRangeOnResize: true,
                rightBarStaysOnScroll: true,
                borderVisible: false,
                visible: true,
                tickMarkFormatter: (time) => {
                    return new Date(time * 1000).toLocaleDateString();
                },
            },
            ...options
        });
        
        // Apply crosshair options to hide labels
        chart.applyOptions({
            crosshair: {
                horzLine: {
                    visible: false,
                    labelVisible: false,
                },
                vertLine: {
                    labelVisible: false,
                },
            },
        });
        
        window.charts[containerId] = chart;
        return chart;
    }
    
    function createTooltipHandler(chart, series, tooltipId, title, valueFormatter = (v) => v.toFixed(2), timesteps) {
        const tooltip = document.getElementById(tooltipId);
            const toolTipWidth = 120;
            const toolTipHeight = 80;
            const toolTipMargin = 15;
            
        chart.subscribeCrosshairMove(param => {
                if (
                    param.point === undefined ||
                    !param.time ||
                    param.point.x < 0 ||
                param.point.x > chart.chartElement().clientWidth ||
                    param.point.y < 0 ||
                param.point.y > chart.chartElement().clientHeight
                ) {
                tooltip.style.display = 'none';
                } else {
                const data = param.seriesData.get(series);
                    if (data && data.value !== undefined) {
                        // Convert timestamp back to timestep for display
                        const baseTime = Math.floor(Date.now() / 1000) - (timesteps.length * 60);
                        const timestep = Math.round((param.time - baseTime) / 60) + 1;
                        
                    tooltip.style.display = 'block';
                    tooltip.innerHTML = `
                        <div style="color: #4BC0C0; font-weight: bold;">${title}</div>
                            <div style="font-size: 18px; margin: 4px 0px; color: black;">
                            ${valueFormatter(data.value)}
                            </div>
                        <div style="color: black; font-size: 10px;">
                                Timestep: ${timestep.toLocaleString()}
                            </div>`;
                        
                    const coordinate = series.priceToCoordinate(data.value);
                        let shiftedCoordinate = param.point.x - 60;
                        
                        if (coordinate === null) {
                            return;
                        }
                        
                        shiftedCoordinate = Math.max(
                            0,
                        Math.min(chart.chartElement().clientWidth - toolTipWidth, shiftedCoordinate)
                        );
                        
                        const coordinateY =
                            coordinate - toolTipHeight - toolTipMargin > 0
                                ? coordinate - toolTipHeight - toolTipMargin
                                : Math.max(
                                    0,
                                    Math.min(
                                    chart.chartElement().clientHeight - toolTipHeight - toolTipMargin,
                                        coordinate + toolTipMargin
                                    )
                                );
                        
                    tooltip.style.left = shiftedCoordinate + 'px';
                    tooltip.style.top = coordinateY + 'px';
                    } else {
                    tooltip.style.display = 'none';
                    }
                }
            });
    }
    
    function plotMetrics(metrics) {
        if (!metrics || metrics.length === 0) {
                            return;
                        }
                        
        const timesteps = metrics.map(m => m.timesteps);
        
        // Update training info (async)
        updateTrainingInfo(metrics).catch(error => {
            console.error('Error updating training info:', error);
        });
            
        // Helper function to create line series data
        function createLineData(values, color) {
            // Convert timesteps to timestamps (seconds since epoch)
            const baseTime = Math.floor(Date.now() / 1000) - (timesteps.length * 60); // Start from 1 minute ago
            const data = values.map((value, index) => ({
                time: baseTime + (index * 60), // Each point is 1 minute apart
                value: value !== null && value !== undefined ? value : 0
            }));
            return data;
                        }
                        
        try {
            // Rewards Chart (merged with Mean Reward)
            const rewardsChart = createTradingViewChart('rewards-chart', null, {});
            if (rewardsChart) {
                const rewardsSeries = rewardsChart.addLineSeries({ color: '#4BC0C0', lineWidth: 2 });
                const meanRewardSeries = rewardsChart.addLineSeries({ color: '#32CD32', lineWidth: 2 });
                rewardsSeries.setData(createLineData(safeMap(metrics, 'reward')));
                meanRewardSeries.setData(createLineData(safeMap(metrics, 'mean_reward_100')));
            
                // Enhanced tooltip for Rewards with multiple series
                const rewardsTooltip = document.getElementById('rewards-tooltip');
                const toolTipWidth = 120;
                const toolTipHeight = 80;
                const toolTipMargin = 15;
                
                rewardsChart.subscribeCrosshairMove(param => {
                if (
                    param.point === undefined ||
                    !param.time ||
                    param.point.x < 0 ||
                        param.point.x > rewardsChart.chartElement().clientWidth ||
                    param.point.y < 0 ||
                        param.point.y > rewardsChart.chartElement().clientHeight
                ) {
                        rewardsTooltip.style.display = 'none';
                } else {
                        const rewardData = param.seriesData.get(rewardsSeries);
                        const meanRewardData = param.seriesData.get(meanRewardSeries);
                        
                        if (rewardData || meanRewardData) {
                        const baseTime = Math.floor(Date.now() / 1000) - (timesteps.length * 60);
                        const timestep = Math.round((param.time - baseTime) / 60) + 1;
                        
                            rewardsTooltip.style.display = 'block';
                            rewardsTooltip.innerHTML = `
                                <div style="color: #4BC0C0; font-weight: bold;">Rewards</div>
                            <div style="font-size: 18px; margin: 4px 0px; color: black;">
                                    ${rewardData ? formatNumber(rewardData.value, 2) : 'N/A'}
                                </div>
                                <div style="color: #32CD32; font-size: 12px;">
                                    Mean (100): ${meanRewardData ? formatNumber(meanRewardData.value, 2) : 'N/A'}
                            </div>
                            <div style="color: black; font-size: 10px;">
                                Timestep: ${timestep.toLocaleString()}
                            </div>`;
                        
                            const coordinate = rewardsSeries.priceToCoordinate(rewardData ? rewardData.value : 0);
                        let shiftedCoordinate = param.point.x - 60;
                        
                        if (coordinate === null) {
                            return;
                        }
                        
                        shiftedCoordinate = Math.max(
                            0,
                                Math.min(rewardsChart.chartElement().clientWidth - toolTipWidth, shiftedCoordinate)
                        );
                        
                        const coordinateY =
                            coordinate - toolTipHeight - toolTipMargin > 0
                                ? coordinate - toolTipHeight - toolTipMargin
                                : Math.max(
                                    0,
                                    Math.min(
                                            rewardsChart.chartElement().clientHeight - toolTipHeight - toolTipMargin,
                                        coordinate + toolTipMargin
                                    )
                                );
                        
                            rewardsTooltip.style.left = shiftedCoordinate + 'px';
                            rewardsTooltip.style.top = coordinateY + 'px';
                    } else {
                            rewardsTooltip.style.display = 'none';
                    }
                }
            });
            }
            
            // Loss Chart
            const lossChart = createTradingViewChart('loss-chart', null, {});
            if (lossChart) {
                const lossSeries = lossChart.addLineSeries({ color: '#DC143C', lineWidth: 2 });
                lossSeries.setData(createLineData(safeMap(metrics, 'loss')));
                createTooltipHandler(lossChart, lossSeries, 'loss-tooltip', 'Loss', 
                    (v) => formatNumber(v, 4), timesteps);
            }
            
            // Account Overview Chart (merged Balance, Commission, and Profit)
            const accountChart = createTradingViewChart('account-chart', null, {});
            if (accountChart) {
                const balanceSeries = accountChart.addLineSeries({ color: '#0000FF', lineWidth: 2 });
                const totalCommissionSeries = accountChart.addLineSeries({ color: '#FF6B6B', lineWidth: 2 });
                const profitSeries = accountChart.addLineSeries({ color: '#32CD32', lineWidth: 2 });
                
                balanceSeries.setData(createLineData(safeMap(metrics, 'balance')));
                totalCommissionSeries.setData(createLineData(safeMap(metrics, 'total_commission')));
                
                // Calculate profit as equity - 1000
                const profitData = createLineData(safeMap(metrics, 'equity').map(equity => 
                    equity !== null && equity !== undefined ? equity - 1000 : null
                ));
                profitSeries.setData(profitData);
            
                // Enhanced tooltip for Account Overview with multiple series
                const accountTooltip = document.getElementById('account-tooltip');
                const toolTipWidth = 120;
                const toolTipHeight = 100;
                const toolTipMargin = 15;
                
                accountChart.subscribeCrosshairMove(param => {
                if (
                    param.point === undefined ||
                    !param.time ||
                    param.point.x < 0 ||
                        param.point.x > accountChart.chartElement().clientWidth ||
                    param.point.y < 0 ||
                        param.point.y > accountChart.chartElement().clientHeight
                ) {
                        accountTooltip.style.display = 'none';
                } else {
                                                const balanceData = param.seriesData.get(balanceSeries);
                        const totalCommissionData = param.seriesData.get(totalCommissionSeries);
                        const profitData = param.seriesData.get(profitSeries);
                        
                        if (balanceData || totalCommissionData || profitData) {
                        const baseTime = Math.floor(Date.now() / 1000) - (timesteps.length * 60);
                        const timestep = Math.round((param.time - baseTime) / 60) + 1;
                        
                            accountTooltip.style.display = 'block';
                                                        accountTooltip.innerHTML = `
                                <div style="color: #0000FF; font-weight: bold;">Account Overview</div>
                                <div style="font-size: 16px; margin: 2px 0px; color: black;">
                                    Balance: ${balanceData ? formatCurrency(balanceData.value) : 'N/A'}
                                </div>

                                <div style="font-size: 14px; margin: 2px 0px; color: #32CD32;">
                                    Profit: ${profitData ? formatCurrency(profitData.value) : 'N/A'}
                                </div>
                                <div style="font-size: 12px; margin: 2px 0px; color: #FF6B6B;">
                                    Commission: ${totalCommissionData ? formatCurrency(totalCommissionData.value) : 'N/A'}
                                </div>
                                <div style="color: black; font-size: 10px;">
                                    Timestep: ${timestep.toLocaleString()}
                                </div>`;
                        
                            const coordinate = balanceSeries.priceToCoordinate(balanceData ? balanceData.value : 0);
                        let shiftedCoordinate = param.point.x - 60;
                        
                        if (coordinate === null) {
                            return;
                        }
                        
                        shiftedCoordinate = Math.max(
                            0,
                                Math.min(accountChart.chartElement().clientWidth - toolTipWidth, shiftedCoordinate)
                        );
                        
                        const coordinateY =
                            coordinate - toolTipHeight - toolTipMargin > 0
                                ? coordinate - toolTipHeight - toolTipMargin
                                : Math.max(
                                    0,
                                    Math.min(
                                            accountChart.chartElement().clientHeight - toolTipHeight - toolTipMargin,
                                        coordinate + toolTipMargin
                                    )
                                );
                        
                            accountTooltip.style.left = shiftedCoordinate + 'px';
                            accountTooltip.style.top = coordinateY + 'px';
                    } else {
                            accountTooltip.style.display = 'none';
                    }
                }
            });
            }
            
            // Total Trades Chart
            const tradesChart = createTradingViewChart('trades-chart', null, {});
            if (tradesChart) {
                const tradesSeries = tradesChart.addLineSeries({ color: '#0000FF', lineWidth: 2 });
                tradesSeries.setData(createLineData(safeMap(metrics, 'total_trades')));
                createTooltipHandler(tradesChart, tradesSeries, 'trades-tooltip', 'Total Trades', 
                    (v) => formatNumber(v, 0), timesteps);
            }
            
            // Entropy Chart
            const entropyChart = createTradingViewChart('entropy-chart', null, {});
            if (entropyChart) {
            const entropySeries = entropyChart.addLineSeries({
                color: '#800000',
                lineWidth: 2,
                priceFormat: {
                    type: 'price',
                    precision: 10,
                    minMove: 0.0000000001
                } 
            });
            entropySeries.setData(createLineData(safeMap(metrics, 'entropy')));
                createTooltipHandler(entropyChart, entropySeries, 'entropy-tooltip', 'Entropy', 
                    (v) => formatNumber(v, 10), timesteps);
            }
            

        } catch (error) {
            console.error('Error plotting metrics:', error);
            document.getElementById('error-msg').textContent = `Error plotting charts: ${error.message}`;
        }
    }
    async function updateDashboard() {
        const errorMsg = document.getElementById('error-msg');
        try {
            const metrics = await fetchMetrics();
            if(metrics.error) {
                errorMsg.textContent = metrics.error;
                return;
            }
            errorMsg.textContent = '';
            plotMetrics(metrics);
            
            // Update configuration info
            await updateConfigurationInfo();
        } catch (e) {
            errorMsg.textContent = 'Failed to fetch training metrics.';
        }
    }
    // Dynamic refresh control
    let refreshInterval = null;
    let currentRefreshTime = 60; // Default 60 seconds
    
    function startRefreshTimer(seconds) {
        // Clear existing timer
        if (refreshInterval) {
            clearInterval(refreshInterval);
        }
        
        // Start new timer if seconds > 0
        if (seconds > 0) {
            refreshInterval = setInterval(updateDashboard, seconds * 1000);
            updateRefreshInfo(seconds);
        } else {
            updateRefreshInfo(0);
        }
    }
    
    function updateRefreshInfo(seconds) {
        const refreshInfo = document.getElementById('refresh-info');
        if (seconds === 0) {
            refreshInfo.textContent = 'Manual refresh only';
        } else if (seconds < 60) {
            refreshInfo.textContent = `Auto-refreshing every ${seconds} seconds`;
        } else if (seconds < 120) {
            refreshInfo.textContent = `Auto-refreshing every ${seconds} seconds`;
        } else {
            const minutes = Math.floor(seconds / 60);
            refreshInfo.textContent = `Auto-refreshing every ${minutes} minutes`;
        }
    }
    
    // Event listeners for refresh controls
    document.getElementById('refresh-interval').addEventListener('change', function() {
        const seconds = parseInt(this.value);
        currentRefreshTime = seconds;
        startRefreshTimer(seconds);
    });
    
    document.getElementById('refresh-now').addEventListener('click', function() {
        updateDashboard();
    });
    
    // Initial load and periodic refresh
    updateDashboard();
    startRefreshTimer(currentRefreshTime);
    

    </script>
</body>
</html> 